测试同步功能 - 将药品配置同步到设备

测试控制命令 - 打开药格、测试蜂鸣器

测试提醒功能 - 设置当前时间的药品，看是否提醒

要下载mosquitto

很好！现在问题很清楚了。**Mosquitto 只监听本地回环地址 (127.0.0.1)，没有监听网络接口 (192.168.21.4)**。这是默认配置问题。

## 解决方案：

### 1. 修改 Mosquitto 配置文件

打开 `C:\Program Files\mosquitto\mosquitto.conf`，添加以下配置：

```conf
# 监听所有网络接口（0.0.0.0 表示所有IP）
listener 1883 0.0.0.0

# 或者指定监听你的WiFi IP
# listener 1883 192.168.21.4

# 允许匿名连接（开发环境）
allow_anonymous true

# 日志设置
log_dest stdout
log_type all

# 保持其他默认配置不变
```

### 2. 重启 Mosquitto 使用新配置

**停止服务并重新启动**：

```bash
# 1. 停止服务
net stop mosquitto

# 2. 查看当前配置（可选）
sc query mosquitto

# 3. 以调试模式启动，使用配置文件
cd "C:\Program Files\mosquitto"
mosquitto.exe -c mosquitto.conf -v
```

### 3. 或者修改服务配置

如果你想让服务使用新的配置：

```bash
# 1. 停止服务
net stop mosquitto

# 2. 修改服务配置
sc config mosquitto binPath= "\"C:\Program Files\mosquitto\mosquitto.exe\" -c \"C:\Program Files\mosquitto\mosquitto.conf\""

# 3. 启动服务
net start mosquitto
```

### 4. 快速测试脚本

创建 `fix_mqtt.bat` 并运行：

```batch
@echo off
echo ===== 修复MQTT配置 =====
echo.

echo 1. 停止Mosquitto服务...
net stop mosquitto

echo 2. 创建配置文件...
(
echo listener 1883 0.0.0.0
echo allow_anonymous true
echo log_dest stdout
echo log_type all
) > "C:\Program Files\mosquitto\mosquitto.conf"

echo 3. 更新服务配置...
sc config mosquitto binPath= "\"C:\Program Files\mosquitto\mosquitto.exe\" -c \"C:\Program Files\mosquitto\mosquitto.conf\""

echo 4. 启动服务...
net start mosquitto

echo 5. 等待3秒...
timeout /t 3 >nul

echo 6. 测试本地连接...
start "Local Test" cmd /k "cd /d "C:\Program Files\mosquitto" && mosquitto_sub -h 127.0.0.1 -t "test" -v"

echo 7. 等待2秒...
timeout /t 2 >nul

echo 8. 测试网络连接...
start "Network Test" cmd /k "cd /d "C:\Program Files\mosquitto" && mosquitto_sub -h 192.168.21.4 -t "test" -v"

echo 9. 等待2秒...
timeout /t 2 >nul

echo 10. 发布测试消息...
start "Publisher" cmd /k "cd /d "C:\Program Files\mosquitto" && mosquitto_pub -h 192.168.21.4 -t "test" -m "Network Test Message""

echo.
echo 配置完成！检查各个窗口。
echo 如果网络测试窗口收到消息，则表示成功。
pause
```

### 5. 验证配置是否生效

运行测试命令：

```bash
# 测试1：查看Mosquitto监听的端口
netstat -an | findstr :1883

# 你应该看到类似这样的输出：
# TCP    0.0.0.0:1883           0.0.0.0:0              LISTENING
# TCP    [::]:1883              [::]:0                 LISTENING

# 测试2：验证配置
cd "C:\Program Files\mosquitto"
mosquitto.exe -c mosquitto.conf -v
```

### 6. 防火墙配置（如果仍然有问题）

确保防火墙允许1883端口：

```bash
# 以管理员身份运行
netsh advfirewall firewall add rule name="MQTT 1883" dir=in action=allow protocol=TCP localport=1883
netsh advfirewall firewall add rule name="MQTT 1883 UDP" dir=in action=allow protocol=UDP localport=1883

# 或者临时关闭防火墙测试
netsh advfirewall set allprofiles state off

# 测试完成后重新打开
netsh advfirewall set allprofiles state on
```

### 7. 修改NodeMCU代码

现在NodeMCU应该能够连接了。使用你的诊断代码重新上传到NodeMCU：

```cpp
// ===================== MQTT配置 =====================
const char* mqtt_server = "192.168.21.4";  // 你的PC IP地址
const int mqtt_port = 1883;
const char* mqtt_username = "";
const char* mqtt_password = "";
```

### 8. 最终的验证步骤

请按顺序执行：

1. **步骤1**：运行上面的 `fix_mqtt.bat` 脚本
2. **步骤2**：查看网络测试窗口是否收到消息
3. **步骤3**：重新上传NodeMCU代码
4. **步骤4**：打开串口监视器查看输出

### 9. 如果仍然失败，使用替代方案

#### 方案A：在代码中启动Mosquitto

创建 `MqttStarter.java`：

```java
package com.ycyu.backend.config;

import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.InputStreamReader;

@Configuration
public class MqttStarter {

    @PostConstruct
    public void startMosquitto() {
        try {
            System.out.println("启动Mosquitto MQTT Broker...");
            
            // 停止现有服务
            Process stopProcess = Runtime.getRuntime().exec("net stop mosquitto");
            stopProcess.waitFor();
            
            // 以监听所有接口的模式启动
            String[] command = {
                "C:\\Program Files\\mosquitto\\mosquitto.exe",
                "-v",
                "-p", "1883",
                "-i", "0.0.0.0"
            };
            
            Process process = new ProcessBuilder(command).start();
            
            // 读取输出
            new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(
                        new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        System.out.println("[Mosquitto] " + line);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
            
            System.out.println("Mosquitto MQTT Broker 已启动，监听 0.0.0.0:1883");
            
        } catch (Exception e) {
            System.err.println("启动Mosquitto失败: " + e.getMessage());
        }
    }
}
```

#### 方案B：使用Java内置的MQTT Broker

如果你不想用Mosquitto，可以使用这个简单的Java MQTT服务器：

```java
package com.ycyu.backend.config;

import io.moquette.broker.Server;
import io.moquette.broker.config.IConfig;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;
import java.util.Properties;

@Configuration
public class SimpleMqttServerConfig {
    
    private Server mqttServer;
    
    @PostConstruct
    public void startMqttServer() throws Exception {
        mqttServer = new Server();
        
        Properties props = new Properties();
        props.setProperty("port", "1883");
        props.setProperty("host", "0.0.0.0");
        props.setProperty("allow_anonymous", "true");
        
        IConfig config = IConfig.fromProperties(props);
        mqttServer.startServer(config);
        
        System.out.println("✅ MQTT Server started on 0.0.0.0:1883");
        System.out.println("   Local:     tcp://127.0.0.1:1883");
        System.out.println("   Network:   tcp://192.168.21.4:1883");
    }
}
```

## 请告诉我：

1. 运行 `fix_mqtt.bat` 后，网络测试窗口是否收到消息？
2. 运行 `netstat -an | findstr :1883` 的输出是什么？
3. NodeMCU现在能否连接？

这样我就能知道问题是否解决了。