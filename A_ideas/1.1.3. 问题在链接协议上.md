你现在看到的这个结果，其实 **非常关键，也非常典型** ，它解释了为什么你“改了很多配置但还是乱码”。

先给结论，再解释原因与修复路径：

> ✅ 你的 **MySQL 服务端已经是 utf8mb4**
> ❌ 但**客户端连接仍然在用 latin1 协议在跟服务端说话**
> → 所以一旦涉及中文，就必然出现乱码或异常行为

---

# 一、先看你这份输出在说明什么

你执行的是：

```sql
SHOW VARIABLES LIKE 'character_set%';
SHOW VARIABLES LIKE 'collation%';
```

结果中最关键的是这几行：

```text
character_set_server     = utf8mb4
character_set_database   = utf8mb4
collation_server         = utf8mb4_unicode_ci
collation_database       = utf8mb4_unicode_ci
```

👉 说明：
**库和服务端层面完全没问题，已经是 UTF-8。**

但同时你又看到：

```text
character_set_client     = latin1
character_set_connection = latin1
character_set_results    = latin1
collation_connection     = latin1_swedish_ci
```

👉 说明：
**当前这个连接，是用 latin1 在跟 MySQL 通信。**

这不是数据库存储的问题，而是：

> ⚠️ 客户端—服务端通信协议层的字符集不一致

这正是我之前说的：**不是“库的编码”，而是“连接协议的编码”。**

---

# 二、为什么你改了配置还是没用？

因为你改的，大概率都是这类配置之一：

## 1. 你改的是 MySQL 服务端配置

例如：

```ini
[mysqld]
character-set-server=utf8mb4
collation-server=utf8mb4_unicode_ci
```

或者 Docker 里：

```yaml
command:
  --character-set-server=utf8mb4
  --collation-server=utf8mb4_unicode_ci
```

这些只影响：

* 默认数据库编码
* 新建表的默认编码
* 服务端排序规则

**但不会影响客户端连接用什么字符集。**

---

## 2. 客户端字符集由“连接发起方”决定

你现在是这样连的：

```bash
docker exec -it smart-medicine-box-mysql \
  mysql -uroot -p123456 ...
```

MySQL CLI 默认行为是：

> 如果没有指定 `--default-character-set`
> → 就使用 **latin1**

所以你这个连接天生就是：

```text
client = latin1
connection = latin1
results = latin1
```

这和你数据库本身是不是 utf8mb4  **完全无关** 。

---

## 3. JDBC 也是同一套机制

如果你后端是 Java：

### 旧写法（问题来源）

```text
jdbc:mysql://mysql:3306/dbname
```

默认行为取决于：

* MySQL 版本
* Connector/J 版本
* 服务端握手结果

经常会退回到 latin1 或 utf8mb3。

### 正确写法

```text
jdbc:mysql://mysql:3306/dbname
?useUnicode=true
&characterEncoding=utf8
&connectionCollation=utf8mb4_unicode_ci
&serverTimezone=Asia/Shanghai
```

否则：

> 即使库是 utf8mb4，
> Java 仍可能按 latin1 发数据 → 服务端再按 utf8 存 → 必炸。

---

# 三、为什么这会导致“循环启动 / 异常重连”等诡异问题？

这点你前面其实已经遇到过。

典型链路是：

1. Java 按 UTF-8 发送中文
2. MySQL 连接层按 latin1 解码
3. 字节非法 → 报错
4. Spring Boot 认为数据库异常 → 重连
5. Docker 健康检查失败 → 容器重启
6. 看起来像“服务循环启动”

所以你后来发现：

> 改了 JDBC characterEncoding 之后，循环启动问题消失

这在工程上是 **完全合理的因果关系** 。

---

# 四、如何从根上一次性解决（推荐方案）

## ✅ 1. 服务端：确保默认就是 utf8mb4（你已完成）

Docker MySQL：

```yaml
command:
  --character-set-server=utf8mb4
  --collation-server=utf8mb4_unicode_ci
```

或 my.cnf：

```ini
[mysqld]
character-set-server=utf8mb4
collation-server=utf8mb4_unicode_ci
```

---

## ✅ 2. Java 端：必须在 JDBC URL 指定

```yaml
spring:
  datasource:
    url: jdbc:mysql://mysql:3306/smart_medicine
         ?useUnicode=true
         &characterEncoding=utf8
         &connectionCollation=utf8mb4_unicode_ci
         &serverTimezone=Asia/Shanghai
```

这是 **最关键的一步** 。

---

## ✅ 3. MySQL CLI / 初始化脚本：显式指定字符集

你现在 exec 进去测试时，其实可以这样：

```bash
docker exec -it smart-medicine-box-mysql \
  mysql --default-character-set=utf8mb4 -uroot -p123456
```

进去后再查：

```sql
SHOW VARIABLES LIKE 'character_set%';
```

你会看到：

```text
client = utf8mb4
connection = utf8mb4
results = utf8mb4
```

说明协议层已经对齐。

---

## ✅ 4. 已存在的表仍需确认编码

哪怕数据库是 utf8mb4，老表也可能不是：

```sql
SHOW TABLE STATUS WHERE Name='xxx';
```

或批量：

```sql
SELECT table_name, table_collation
FROM information_schema.tables
WHERE table_schema = 'smart_medicine';
```

如果有 latin1 表，需要：

```sql
ALTER TABLE xxx CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

---

# 五、用一句工程化的话总结为什么你会被这个问题坑到

> MySQL 的字符集是 **分层控制的** ：
> 存储层 ≠ 服务端默认 ≠ 连接协议 ≠ 客户端编码
>
> 你现在的问题不在数据库，而在 **连接协商阶段的字符集退化** 。

而 Docker + JDBC + MySQL8 这个组合，
在字符集这件事上，默认值非常不可靠， **必须显式指定** 。

---

# 六、结合你当前项目状态的判断

结合你前面说的情况（循环启动 + JDBC 报错 + Docker 健康检查异常）：

可以高度确定：

* ✅ MySQL 容器本身没有问题
* ✅ 表结构与库编码也基本没问题
* ❌ 主要问题集中在 **JDBC 连接参数与初始化脚本的字符集**

也就是说，你现在继续折腾 MySQL 配置文件，收益已经很低了，
应该把精力放在：

* Spring datasource URL
* 初始化 SQL 执行方式
* 服务启动顺序与健康检查

这些更“系统工程层”的地方。

---

如果你愿意下一步继续排查，我可以直接帮你看：

* docker-compose.yml 里 MySQL 服务配置
* Spring Boot 的 datasource 配置
* 初始化 SQL 是怎么执行的（schema.sql / data.sql / 自定义脚本）

你可以贴出来，我可以按启动链路给你完整梳理一遍。
